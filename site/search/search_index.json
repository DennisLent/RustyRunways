{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"RustyRunways","text":"<p>RustyRunways is a logistics simulation game where you manage a growing air carrier moving both cargo and passengers: buy planes, schedule departures, balance mixed payloads, refuel, and survive deadlines plus operating costs. Time advances in hours, airports restock every 168 in\u2011game hours, and fuel prices fluctuate every six hours inside a bounded range. Demand heuristics ensure starter-friendly work (roughly two-thirds of visible payloads are flyable by the starter plane, route lengths start short and grow with upgrades) while larger airports seed lucrative cargo and passenger itineraries. The engine is written in Rust and exposed via a CLI, a desktop GUI, and Python bindings.</p> <p>This documentation provides a high\u2011level overview of the project and links to in\u2011depth sections for the core engine, CLI usage, GUI features, and Python APIs.</p>"},{"location":"index.html#project-layout","title":"Project Layout","text":"<ul> <li><code>rusty_runways_core</code>: the simulation engine with all game rules and data structures.</li> <li><code>rusty_runways_cli</code>: a friendly command\u2011line shell around the engine.</li> <li><code>apps/tauri</code>: Tauri + React desktop app \u2014 the recommended, polished UI distributed as installers.</li> <li><code>rusty_runways_gui</code>: a lightweight <code>egui</code> application (development client).</li> <li><code>rusty_runways_py</code>: Python bindings with single and vectorized environments.</li> </ul>"},{"location":"index.html#core-rules-at-a-glance","title":"Core Rules at a Glance","text":"<ul> <li>Fleet management: You begin with one starter aircraft, $650\u202f000 cash, and a randomly generated 12\u2011airport network (unless a YAML world overrides these numbers). Planes must be parked, empty, and solvent to sell or refuel. Buying additional planes requires sufficient funds and a runway long enough for the chosen model.</li> <li>Cargo flow: Each airport surfaces orders between 180\u202fkg and 650\u202fkg with deadlines capped at 96 hours. When <code>regenerate</code> is enabled (default) the network restocks every 168 hours so the player is never starved of work. Delivering before the deadline pays out immediately; missing a deadline forfeits the order value.</li> <li>Operating costs: Fuel updates every six hours inside the <code>[0.6\u00d7, 1.3\u00d7]</code> bounds, and standard fees (fuel buy, landing, parking, maintenance) apply whenever an action uses them. Loading, unloading, refuelling, and maintenance consume one hour each; departure consumes the full travel time calculated from aircraft speed and leg distance.</li> <li>Progression: The first upgrade should be reachable within the first in\u2011game week of focused play. Later aircraft unlock longer routes (the procedural map contains clustered hubs plus longer spokes) and higher late\u2011game margins without manual boosts.</li> <li>Save/Load: Saves capture the full simulation state, including running events and cash flow, so you can resume across CLI, GUI, or Python sessions.</li> </ul>"},{"location":"index.html#quick-start","title":"Quick Start","text":"<p>\u25b6 Play the Web Demo \u2b07 Download Desktop App</p> <ul> <li>Python (pip): <code>pip install rusty-runways</code> \u2014 see Python page for Gym wrappers and extra installs</li> <li>Build: <code>cargo build --release</code></li> <li>CLI: <code>cargo run -p rusty_runways_cli -- --seed 1 --n 5 --c 650000</code></li> <li>GUI (download): see Releases for installers (macOS universal, Windows, Linux).</li> <li>GUI (web demo): try it in your browser \u2014 no install \u2014 see Play Online. Note: save/load and YAML scenarios are only available in Python, Tauri desktop, or native Rust.</li> <li>GUI (from source):</li> <li>Dev: <code>scripts/dev_tauri.sh</code></li> <li>Build: <code>cd apps/tauri/src-tauri &amp;&amp; cargo tauri build</code></li> <li>Python (local dev): <code>cd crates/py &amp;&amp; maturin develop --release</code></li> </ul> <p>Python wrappers and Gymnasium</p> <p>For usage examples and how to enable the optional Gym wrappers, see the Python page: Python Bindings. To install with Gym support: <code>pip install 'rusty-runways[gym]'</code>.</p>"},{"location":"index.html#working-with-the-python-agent","title":"Working with the Python Agent","text":"<p>The Python bindings expose the same rules as the Rust engine. You can:</p> <ol> <li>Instantiate <code>GameEnv</code> or <code>VectorGameEnv</code> with the default parameters or a YAML config (<code>config_path</code>), step the simulation, and issue the same commands the CLI understands via <code>execute()</code>.</li> <li>Wrap the environment with the Gymnasium helpers (<code>RustyRunwaysGymEnv</code>, <code>RustyRunwaysGymVectorEnv</code>) to obtain standard <code>step</code>/<code>reset</code> loops and <code>MultiDiscrete</code> action spaces.</li> <li>Run the sample heuristic agent in <code>benchmarks/run_benchmarks.py</code> to gather feasibility, margin, and upgrade statistics across many seeds. The generated plots highlight early/mid/late phase performance so you can compare code changes or YAML tweaks quickly.</li> </ol> <p>Refer to Python Bindings for complete API details and to the Benchmarks README for the automation workflow.</p> <p>Use the sidebar to navigate to each section. The table of contents on each page follows the headings.</p>"},{"location":"demo.html","title":"Play In Your Browser","text":"<p>Try a lightweight, in\u2011browser build of RustyRunways powered by WebAssembly. This demo runs the core simulation in WASM and the React UI in your browser \u2014 no install needed.</p> <p>Download the Desktop App for Best Experience</p> <p>For the best UX and performance, download the native desktop builds from the Releases page.</p> <p>Download Desktop App</p> <p>Important limitations of the web demo: - Saves/loads: not available in the browser version. - Start from YAML: not available in the browser version. - Performance: CPU/graphics are browser\u2011limited; long runs may be slower. - Persistence: state resets when the page is refreshed.</p> <p>These features (save/load and YAML scenarios) are available via: - Python bindings (CLI + wrappers) - Tauri desktop app - Native Rust build</p>"},{"location":"demo.html#launch-demo","title":"Launch Demo","text":"<p>If the embed doesn't load, open it directly: - Web demo: web-demo/index.html</p>"},{"location":"demo.html#how-it-works","title":"How it works","text":"<ul> <li>The Rust core (<code>crates/core</code>) is compiled to WebAssembly via <code>wasm-bindgen</code> using a thin wrapper crate (<code>crates/wasm</code>).</li> <li>The React UI falls back to calling the WASM API when Tauri is not detected.</li> <li>We build the demo with <code>scripts/build_web_demo.sh</code>, which places a static web build under <code>docs/web-demo/</code> so MkDocs can serve it.</li> </ul>"},{"location":"releases.html","title":"Downloads","text":"<p>Get the latest RustyRunways desktop builds for your platform. These links point to the most recent GitHub Release assets.</p> <ul> <li>Latest release page: https://github.com/DennisLent/RustyRunways/releases/latest</li> <li>All releases: https://github.com/DennisLent/RustyRunways/releases</li> </ul>"},{"location":"releases.html#direct-downloads","title":"Direct downloads","text":"<p>The links below are populated automatically from the latest release assets.</p> <ul> <li>macOS (Apple Silicon): Loading\u2026</li> <li>macOS (Intel): Loading\u2026</li> <li>macOS (Universal): Loading\u2026</li> <li>Windows: Loading\u2026</li> <li>Linux AppImage: Loading\u2026</li> <li>Linux Debian package: Loading\u2026</li> </ul>"},{"location":"releases.html#install-notes","title":"Install notes","text":"<ul> <li>macOS: You may need to allow the app in System Settings if your build isn\u2019t notarized.</li> <li>Windows: The .msi installer will guide you through installation (unsigned builds may show SmartScreen).</li> <li>Linux: Prefer the AppImage for a portable run or the .deb for Debian/Ubuntu.</li> </ul>"},{"location":"cli/index.html","title":"CLI","text":"<p>The CLI (<code>rusty_runways_cli</code>) is a REPL that wraps the core engine. It provides a simple DSL for inspecting state and issuing actions. Game rules and constraints are implemented in the Core.</p>"},{"location":"cli/index.html#running","title":"Running","text":"<pre><code>cargo run -p rusty_runways_cli -- --seed 1 --n 5 --c 650000\n</code></pre> <p><code>--seed</code> and <code>--n</code> must be provided together; <code>--c</code> defaults to <code>650000</code>.</p>"},{"location":"cli/index.html#commands-and-examples","title":"Commands and Examples","text":"<p>Inspecting the world state</p> <ul> <li><code>SHOW AIRPORTS</code></li> <li><code>SHOW AIRPORTS WITH ORDERS</code></li> <li><code>SHOW AIRPORTS &lt;airport_id&gt;</code> \u2014 full details &amp; orders</li> <li><code>SHOW AIRPORTS &lt;airport_id&gt; WITH ORDERS</code> \u2014 orders at that airport</li> <li><code>SHOW PLANES</code> \u2014 player\u2019s fleet</li> <li><code>SHOW PLANES &lt;plane_id&gt;</code> \u2014 one plane (status, specs, manifest)</li> <li><code>SHOW DISTANCES &lt;plane_id&gt;</code> \u2014 distances, fuel requirements, landing feasibility by airport</li> </ul> <p>Purchases</p> <ul> <li><code>BUY PLANE &lt;Model&gt; &lt;airport_id&gt;</code> \u2014 buy and place an airplane at the airport</li> <li><code>SELL PLANE &lt;plane_id&gt;</code> \u2014 sell a parked, empty plane for a 60% refund</li> </ul> <p>Cargo handling</p> <ul> <li><code>LOAD ORDER &lt;order_id&gt; ON &lt;plane_id&gt;</code> \u2014 load a single order (+1h)</li> <li><code>LOAD ORDERS [&lt;order_id&gt;] ON &lt;plane_id&gt;</code> \u2014 load multiple (+1h)</li> <li><code>UNLOAD ORDER &lt;order_id&gt; FROM &lt;plane_id&gt;</code> \u2014 unload a single order (+1h)</li> <li><code>UNLOAD ORDERS [&lt;order_id&gt;] FROM &lt;plane_id&gt;</code> \u2014 unload selected (+1h)</li> <li><code>UNLOAD ALL FROM &lt;plane_id&gt;</code> \u2014 unload all (+1h)</li> <li><code>REFUEL PLANE &lt;plane_id&gt;</code> \u2014 refuel (+1h)</li> </ul> <p>Dispatch &amp; movement</p> <ul> <li><code>DEPART PLANE &lt;plane_id&gt; &lt;destination_airport_id&gt;</code> \u2014 depart to destination</li> <li><code>HOLD PLANE &lt;plane_id&gt;</code> \u2014 remain parked</li> <li><code>MAINTENANCE &lt;plane_id&gt;</code> \u2014 routine maintenance (+1h)</li> </ul> <p>Time control</p> <ul> <li><code>ADVANCE &lt;n&gt;</code> \u2014 advance by <code>n</code> hours (or until next event)</li> </ul> <p>Queries</p> <ul> <li><code>SHOW CASH</code></li> <li><code>SHOW TIME</code></li> <li><code>SHOW STATS</code></li> <li><code>SHOW MODELS</code> \u2014 list all airplane models with specs table</li> </ul> <p>Game</p> <ul> <li><code>SAVE &lt;game_name&gt;</code> \u2014 save game</li> <li><code>LOAD &lt;game_name&gt;</code> \u2014 load game</li> <li><code>LOAD CONFIG &lt;path.yaml&gt;</code> \u2014 rebuild game from a custom YAML world</li> <li><code>EXIT</code> \u2014 exit the REPL</li> </ul>"},{"location":"core/index.html","title":"Core Engine","text":"<p>The <code>rusty_runways_core</code> crate implements all game rules and the event\u2011driven simulation. It is I/O\u2011free and can be embedded in different frontends (CLI, GUI, Python).</p>"},{"location":"core/index.html#core-concepts","title":"Core Concepts","text":"<ul> <li>Game state (<code>Game</code>): time, player, airplanes, airports, scheduled events, and logs.</li> <li>Airports: name, coordinates, fees, runway length, dynamic fuel price, and outstanding orders.</li> <li>Airplanes: model, specs, location, status, manifest, and operational costs.</li> <li>Orders: either cargo (type, weight) or passenger groups (count), plus value, deadline, origin, destination.</li> <li>Player: cash, fleet, deliveries; can buy planes subject to constraints.</li> </ul>"},{"location":"core/index.html#game-rules","title":"Game Rules","text":"<ul> <li>Time advances in integer hours. Many actions (load, unload, refuel, maintenance) consume one hour.</li> <li>Deadlines are tracked in hours. Delivering after a deadline is considered a failure (penalties are handled in the engine\u2019s accounting/events layer).</li> <li>Airports charge fuel by liter and fees (parking/landing) based on usage and mass.</li> <li>Airplane movement is constrained by range and runway length at both origin and destination.</li> </ul>"},{"location":"core/index.html#loading-unloading-refueling","title":"Loading, Unloading, Refueling","text":"<ul> <li>Load order: <code>Game::load_order(order_id, plane_id)</code></li> <li>Requires the plane to be parked at an airport that holds the order.</li> <li>Checks payload capacity; schedules a loading event (+1h).</li> <li>Unload orders</li> <li><code>unload_order(order_id, plane_id)</code> for a single order.</li> <li><code>unload_all(plane_id)</code> to empty the manifest.</li> <li>Schedules unloading events (+1h).</li> <li>Refuel plane: <code>refuel_plane(plane_id)</code> schedules refueling (+1h) and charges the price per liter at the airport.</li> </ul>"},{"location":"core/index.html#passing-of-time","title":"Passing of Time","text":"<ul> <li><code>advance(hours)</code> progresses the simulation by the requested amount or until the next event.</li> <li>Events include arrivals, load/unload completions, maintenance, deadlines, and breakdowns.</li> <li>The engine accrues income and expenses (operating costs, purchases) as time passes and actions occur.</li> </ul>"},{"location":"core/index.html#world-generation-seedable","title":"World Generation (Seedable)","text":"<ul> <li>A new game is created via <code>Game::new(seed, num_airports, starting_cash)</code>.</li> <li>The world uses deterministic PRNG seeding:</li> <li>Airports (positions, names, fees, runway lengths) are generated based on the seed and <code>num_airports</code>.</li> <li>Orders originate at airports with randomized types, weights, deadlines, and destinations.</li> <li>The same seed produces the same world layout and initial orders.</li> </ul>"},{"location":"core/index.html#maintenance","title":"Maintenance","text":"<ul> <li>Airplanes can be set to maintenance (<code>maintenance_on_airplane(plane_id)</code>), which takes time and can prevent breakdowns.</li> <li>Skipping routine checks increases the risk of failures (modeled by the engine), grounding planes and delaying operations.</li> </ul>"},{"location":"core/index.html#fuel-prices","title":"Fuel Prices","text":"<ul> <li>Each airport has a fuel price per liter. Refueling charges depend on the quantity and local pricing.</li> <li>Dynamic pricing nudges prices up or down by the configured elasticity each <code>fuel_interval_hours</code>, clamped between the configured minimum and maximum multipliers of the airport's base price.</li> <li>Strategy: refuel where cheaper, accounting for range, payload, and deadlines.</li> </ul>"},{"location":"core/index.html#airplanes","title":"Airplanes","text":"<p>All models (see <code>utils::airplanes::models</code>):</p> <ul> <li>SparrowLight \u2013 short-range combi prop</li> <li>FalconJet \u2013 light biz jet (passenger)</li> <li>CometRegional \u2013 regional turbofan (passenger)</li> <li>Atlas \u2013 narrow-body combi</li> <li>TitanHeavy \u2013 wide-body freighter (cargo)</li> <li>Goliath \u2013 super-heavy freighter (cargo)</li> <li>Zephyr \u2013 long-range twin-aisle (passenger)</li> <li>Lightning \u2013 supersonic small jet (passenger)</li> <li>BisonFreighter \u2013 medium cargo hauler</li> <li>TrailblazerCombi \u2013 high-capacity combi aircraft</li> </ul> <p>Each model exposes specs via <code>AirplaneModel::specs()</code> including:</p> <ul> <li>MTOW, cruise speed (km/h), fuel capacity (L), fuel consumption (L/h), operating cost ($/h), cargo payload capacity (kg), passenger capacity (seats), model role (cargo/passenger/mixed), purchase price, and computed minimum runway length (m).</li> <li>Players may sell a parked, empty airplane back to the market for 60% of its purchase price.</li> </ul>"},{"location":"core/index.html#custom-airplane-catalog-yaml","title":"Custom Airplane Catalog (YAML)","text":"<p>Scenarios can replace or extend the built\u2011in airplane catalog via the world YAML. Add an <code>airplanes</code> block at the top level:</p> <pre><code>airplanes:\n  strategy: replace   # or: add (default)\n  models:\n    - name: WorkshopCombi\n      mtow: 15000.0\n      cruise_speed: 520.0\n      fuel_capacity: 3200.0\n      fuel_consumption: 260.0\n      operating_cost: 950.0\n      payload_capacity: 3200.0\n      passenger_capacity: 24\n      purchase_price: 780000.0\n      min_runway_length: 1200.0\n      role: Mixed        # Cargo | Passenger | Mixed\n</code></pre> <ul> <li>strategy=replace uses only the declared models. strategy=add merges them with defaults.</li> <li>All fields are required. Validation enforces positive values and role\u2011specific capacities:</li> <li>Cargo requires payload_capacity &gt; 0</li> <li>Passenger requires passenger_capacity &gt; 0</li> <li>Mixed requires both &gt; 0</li> </ul> <p>Games started from this YAML will list these models in the CLI, Python, and Tauri UI and allow buying them by name.</p>"},{"location":"core/index.html#landing-constraints-and-derivation","title":"Landing Constraints and Derivation","text":"<p>Minimum runway length is derived from simplified physics based on the airplane\u2019s cruise speed, assumed takeoff speed (~0.65\u00b7cruise), acceleration, and deceleration:</p> <ul> <li>Takeoff distance: <code>v\u00b2 / (2a)</code> with <code>a \u2248 2.5 m/s\u00b2</code>.</li> <li>Landing distance: <code>v\u00b2 / (2d)</code> with <code>d \u2248 4.0 m/s\u00b2</code>.</li> <li>The required runway length is the max of the two. Airports must meet this requirement to allow takeoff/landing for a model.</li> </ul>"},{"location":"core/airplanes.html","title":"Airplane Models","text":"<p>RustyRunways features a range of aircraft tuned for different roles and budgets. All models are defined in <code>utils::airplanes::models</code> and expose specs via <code>AirplaneModel::specs()</code>.</p>"},{"location":"core/airplanes.html#available-models-and-specs","title":"Available Models and Specs","text":"<p>Each row lists the model\u2019s specs as defined in the code and the computed minimum runway requirement (meters) derived from simplified physics in the core crate. The role and passenger capacity columns reflect the new passenger/cargo support: cargo-only aircraft have <code>0</code> seats, passenger-only aircraft have non\u2011zero seats and a smaller or zero payload capacity, and mixed \u201ccombi\u201d aircraft support both.</p> Model Role MTOW (kg) Cruise (km/h) Fuel (L) Burn (L/h) Oper. Cost ($/h) Payload (kg) Pax (seats) Price ($) Min Runway (m) SparrowLight Mixed 5,200 260 240 35 340 1,200 6 240,000 441 FalconJet Passenger 8,300 780 2,200 260 1,600 600 12 1,700,000 3,967 CometRegional Passenger 24,000 720 6,000 620 3,200 4,000 78 12,000,000 3,380 Atlas Mixed 42,000 750 12,500 1,550 6,500 18,000 68 34,000,000 3,668 TitanHeavy Cargo 110,000 670 22,000 3,200 11,000 55,000 0 68,000,000 2,927 Goliath Cargo 210,000 580 45,000 6,500 22,000 110,000 0 130,000,000 2,193 Zephyr Passenger 82,000 900 28,000 1,450 9,000 8,000 210 72,000,000 5,281 Lightning Passenger 18,500 1,800 5,400 1,100 12,000 1,500 32 88,000,000 21,125 BisonFreighter Cargo 28,000 680 8,500 900 4,800 20,000 0 18,000,000 3,015 TrailblazerCombi Mixed 65,000 820 18,000 1,800 7,500 25,000 120 55,000,000 4,384 <p>Note:</p> <ul> <li>Minimum runway is computed as the max of takeoff and landing distances using assumptions from the code. With the current parameters, takeoff distance dominates: <code>min_runway \u2248 (0.65 \u00b7 cruise_mps)\u00b2 / (2\u00b72.5)</code> and <code>cruise_mps = cruise_kmh / 3.6</code>.</li> <li>Values are rounded to the nearest meter for readability.</li> </ul>"},{"location":"core/airplanes.html#fields-reference","title":"Fields Reference","text":"<ul> <li><code>mtow</code>: maximum take\u2011off weight (kg)</li> <li><code>cruise_speed</code>: km/h</li> <li><code>fuel_capacity</code>: liters</li> <li><code>fuel_consumption</code>: liters per hour</li> <li><code>operating_cost</code>: $/hour</li> <li><code>payload_capacity</code>: kg (cargo)</li> <li><code>passenger_capacity</code>: seats (people)</li> <li><code>role</code>: Cargo / Passenger / Mixed</li> <li><code>purchase_price</code>: $</li> <li><code>min_runway_length</code>: meters, computed from cruise speed with fixed acceleration/deceleration constants</li> </ul>"},{"location":"core/custom_worlds.html","title":"Custom Worlds (YAML)","text":"<p>RustyRunways can load fully custom worlds from a YAML file. This allows you to define airports, fees, initial orders, and gameplay pacing deterministically while still supporting randomly generated content. When airports are generated, they are placed in deterministic clusters so each map starts with local routes for small aircraft and longer hops for bigger planes. You can use YAML files to tweak the economy (restock cadence, order weights, fuel volatility), shape the network layout, or author handcrafted scenarios for testing new mechanics.</p>"},{"location":"core/custom_worlds.html#schema","title":"Schema","text":"<p>Top\u2011level keys:</p> <ul> <li><code>version</code> (int): schema version; currently <code>1</code>.</li> <li><code>seed</code> (int, optional): base seed for determinism (used for generated elements).</li> <li><code>starting_cash</code> (float, optional, default <code>650_000.0</code>).</li> <li><code>num_airports</code> (int, optional): number of airports to generate automatically when <code>airports</code> is omitted.</li> <li><code>airports</code> (list, optional): explicit or partially specified airport definitions.</li> <li><code>gameplay</code> (object, optional): tuning knobs for restocking cadence, fuel price behaviour, and order generation.</li> </ul> <p>Airport fields (everything except <code>id</code>/<code>name</code> optional):</p> <ul> <li><code>id</code> (int): unique across all airports.</li> <li><code>name</code> (string): must be unique (case\u2011insensitive).</li> <li><code>location</code> (object, optional): <code>{ x: float, y: float }</code> \u2014 bounds <code>[0, 10000]</code> each. When omitted a location is generated based on the seed (airports are laid out in clusters to guarantee local routes).</li> <li><code>runway_length_m</code> (float &gt; 0, optional): runway length in meters (generated deterministically when missing).</li> <li><code>fuel_price_per_l</code> (float &gt; 0, optional): $/L (generated when missing).</li> <li><code>landing_fee_per_ton</code> (float &gt;= 0, optional): $ per ton MTOW (generated when missing).</li> <li><code>parking_fee_per_hour</code> (float &gt;= 0, optional): $ per hour (generated when missing).</li> <li><code>orders</code> (list, optional): static orders to seed the airport with. Required when order regeneration is disabled.</li> </ul> <p>Manual order fields (choose cargo or passengers per entry):</p> <ul> <li>Cargo orders:</li> <li><code>cargo</code> (string): any <code>CargoType</code> variant (e.g., <code>Food</code>, <code>Electronics</code>).</li> <li><code>weight</code> (float &gt; 0): weight in kilograms.</li> <li><code>value</code> (float &gt;= 0): payout in dollars.</li> <li><code>deadline_hours</code> (int &gt; 0): deadline window in hours.</li> <li><code>destination_id</code> (int): airport id the cargo must reach (must exist and differ from the origin).</li> <li>Passenger orders:</li> <li><code>passengers</code> (int &gt; 0): number of travellers waiting for the route.</li> <li><code>value</code> (float &gt;= 0): payout in dollars.</li> <li><code>deadline_hours</code> (int &gt; 0): deadline window in hours.</li> <li><code>destination_id</code> (int): airport id the passengers want to reach (must exist and differ from the origin).</li> </ul> <p>Gameplay tuning (defaults shown):</p> <ul> <li><code>restock_cycle_hours</code> (int, default <code>168</code>): cadence for regeneration cycles.</li> <li><code>fuel_interval_hours</code> (int, default <code>6</code>): cadence for dynamic fuel price adjustments.</li> <li><code>fuel</code> (object):</li> <li><code>elasticity</code> (float, default <code>0.04</code>): fractional step applied when prices move up or down.</li> <li><code>min_price_multiplier</code> (float, default <code>0.6</code>): floor expressed as a multiple of each airport's base price.</li> <li><code>max_price_multiplier</code> (float, default <code>1.3</code>): ceiling expressed as a multiple of each airport's base price.</li> <li><code>orders</code> (object):</li> <li><code>regenerate</code> (bool, default <code>true</code>): whether airports restock after the initial load.</li> <li><code>generate_initial</code> (bool, default <code>true</code>): whether random orders are generated at time 0.</li> <li><code>max_deadline_hours</code> (int, default <code>96</code>): maximum deadline assigned to generated orders.</li> <li><code>min_weight</code> (float, default <code>180.0</code>): minimum cargo weight (kg) for generated orders.</li> <li><code>max_weight</code> (float, default <code>650.0</code>): maximum cargo weight (kg) for generated orders.</li> <li><code>alpha</code> (float, default <code>0.12</code>): distance multiplier in the value calculation.</li> <li><code>beta</code> (float, default <code>0.55</code>): urgency multiplier in the value calculation.</li> <li><code>passengers</code> (object, optional): passenger generation tuning.<ul> <li><code>max_deadline_hours</code> (int, default <code>48</code>).</li> <li><code>min_count</code> (int, default <code>4</code>).</li> <li><code>max_count</code> (int, default <code>220</code>).</li> <li><code>alpha</code> (float, default <code>0.10</code>).</li> <li><code>beta</code> (float, default <code>0.40</code>).</li> <li><code>fare_per_km</code> (float, default <code>9.5</code>).</li> </ul> </li> </ul>"},{"location":"core/custom_worlds.html#common-customisations","title":"Common Customisations","text":"<p>The most frequently adjusted knobs are the <code>gameplay</code> block and the payload/deadline limits inside <code>orders</code>. Increasing <code>restock_cycle_hours</code> slows down how quickly new work appears. Lowering <code>max_weight</code> keeps starter planes relevant for longer, whereas raising it forces players to invest in larger aircraft earlier. Tightening the fuel <code>min_price_multiplier</code> and <code>max_price_multiplier</code> narrows price swings, making cash flow more predictable during playtests. For handcrafted cargo/passenger chains, disable regeneration (<code>regenerate: false</code>) and list explicit <code>orders</code> for each airport.</p> <p>Every change can be tested immediately by pointing the CLI, GUI, or Python environment at your YAML file. Because the schema defaults to the tuned KPIs, omitting a field means \u201cuse the balanced value.\u201d</p>"},{"location":"core/custom_worlds.html#examples","title":"Examples","text":"<p>Tuned restocking with explicit airports:</p> <pre><code>version: 1\nseed: 42\nstarting_cash: 650000.0\nairports:\n  - id: 0\n    name: HUB\n    location: { x: 1000.0, y: 1000.0 }\n    runway_length_m: 3500.0\n    fuel_price_per_l: 1.2\n    landing_fee_per_ton: 5.0\n    parking_fee_per_hour: 20.0\n  - id: 1\n    name: AAB\n    location: { x: 3000.0, y: 2000.0 }\n    runway_length_m: 2800.0\n    fuel_price_per_l: 1.7\n    landing_fee_per_ton: 4.5\n    parking_fee_per_hour: 15.0\n\ngameplay:\n  restock_cycle_hours: 168\n  fuel_interval_hours: 4\n  fuel:\n    elasticity: 0.04\n    min_price_multiplier: 0.6\n    max_price_multiplier: 1.3\n  orders:\n    regenerate: true\n    generate_initial: true\n    max_deadline_hours: 96\n    min_weight: 180.0\n    max_weight: 650.0\n    alpha: 0.12\n    beta: 0.55\n</code></pre> <p>Random airports with delayed restock:</p> <pre><code>version: 1\nseed: 99\nstarting_cash: 750000.0\nnum_airports: 5\ngameplay:\n  orders:\n    regenerate: true\n    generate_initial: false\n</code></pre> <p>Minimal airport definitions (locations and fees generated from the seed):</p> <pre><code>version: 1\nseed: 12\nstarting_cash: 600000.0\nairports:\n  - id: 0\n    name: GATEWAY\n  - id: 1\n    name: SPOKE\n    fuel_price_per_l: 1.6\n    runway_length_m: 2400.0\n</code></pre> <p>Static manual orders (no regeneration):</p> <pre><code>version: 1\nseed: 3\nstarting_cash: 800000.0\nairports:\n  - id: 0\n    name: HUB\n    location: { x: 1200.0, y: 900.0 }\n    runway_length_m: 3200.0\n    fuel_price_per_l: 1.5\n    landing_fee_per_ton: 4.5\n    parking_fee_per_hour: 18.0\n    orders:\n      - cargo: Food\n        weight: 550.0\n        value: 2700.0\n        deadline_hours: 48\n        destination_id: 1\n  - id: 1\n    name: AAX\n    location: { x: 3400.0, y: 2100.0 }\n    runway_length_m: 2400.0\n    fuel_price_per_l: 1.8\n    landing_fee_per_ton: 4.0\n    parking_fee_per_hour: 16.0\n    orders:\n      - cargo: Electronics\n        weight: 300.0\n        value: 4200.0\n        deadline_hours: 36\n        destination_id: 0\n\ngameplay:\n  orders:\n    regenerate: false\n    generate_initial: false\n</code></pre>"},{"location":"core/custom_worlds.html#using-configs","title":"Using Configs","text":"<ul> <li> <p>CLI: Start with <code>cargo run -p rusty_runways_cli -- --config examples/sample_world.yaml</code> or, from inside the REPL, load a new scenario with <code>LOAD CONFIG examples/sample_world_no_orders.yaml</code>.</p> </li> <li> <p>GUI: From the desktop main menu choose \u201cStart From Config,\u201d pick the YAML file, review the preview, and launch the game.</p> </li> <li> <p>Python: Pass <code>config_path</code> to <code>GameEnv</code> or <code>VectorGameEnv</code>, e.g. <code>GameEnv(config_path=\"examples/sample_world.yaml\")</code> for a single environment or <code>VectorGameEnv(4, config_path=\"benchmarks/sanity.yaml\")</code> to spin up multiple copies.</p> </li> </ul> <p>After loading a YAML world you can still use commands or agent actions exactly as in the default game. The YAML simply seeds the initial state and tuning values.</p>"},{"location":"core/custom_worlds.html#validation-errors","title":"Validation &amp; Errors","text":"<ul> <li>Provide either explicit <code>airports</code> or <code>num_airports</code> (minimal airport entries are allowed; missing fields are generated).</li> <li>Duplicate airport IDs \u2192 error.</li> <li>Duplicate airport names (case\u2011insensitive) \u2192 error.</li> <li>Invalid coordinates (outside <code>[0, 10000]</code>) \u2192 error.</li> <li>Non\u2011positive runway length or fuel price \u2192 error.</li> <li>Fuel tuning: <code>elasticity</code> must be in <code>(0,1)</code>, <code>min_price_multiplier &gt; 0</code>, and <code>max_price_multiplier &gt;= min_price_multiplier</code> (typically &gt; 1).</li> <li><code>orders.regenerate: false</code> requires every listed airport to provide at least one manual order.</li> </ul> <p>Common issues:</p> <ul> <li>Wrong extension: ensure <code>.yaml</code> or <code>.yml</code>.</li> <li>Paths: in GUI browse for a file; in CLI/Python provide a proper relative/absolute path.</li> </ul>"},{"location":"core/custom_worlds.html#constraints-and-future-extensions","title":"Constraints and Future Extensions","text":"<p>Future schema versions may allow blending generated and explicit airports, richer economic tuning, and batch configurations for automated telemetry runs.</p>"},{"location":"core/economy.html","title":"Economy and Costs","text":"<p>RustyRunways tracks income and expenses daily. Player cash changes as you buy planes, pay fees, and deliver orders.</p>"},{"location":"core/economy.html#cash-flows","title":"Cash Flows","text":"<ul> <li>Income: order deliveries credited upon successful unload at destination.</li> <li>Expenses: purchase prices, operating costs during flight, landing fees, fuel purchases, parking fees, maintenance.</li> <li>The engine maintains <code>daily_income</code> and <code>daily_expenses</code> aggregates for quick stats.</li> </ul>"},{"location":"core/economy.html#fees-and-prices","title":"Fees and Prices","text":"<ul> <li>Landing fee: <code>airport.landing_fee(airplane) = airport.landing_fee_base * (MTOW / 1000)</code>.</li> <li>Parking fee: per hour, based on airport size (runway length proxy).</li> <li>Fuel price: each airport has <code>fuel_price</code> ($/L), generated within <code>[0.5, 2.5]</code> and adjusted dynamically.</li> </ul>"},{"location":"core/economy.html#dynamic-fuel-pricing","title":"Dynamic Fuel Pricing","text":"<ul> <li>Airports track <code>fuel_sold</code> and adjust prices every pricing event (e.g., every 6 hours):</li> <li>If fuel was bought: <code>price *= (1 + 0.05)</code> (elastic increase)</li> <li>Else: <code>price += (1 - 0.05)</code> (drift upwards to encourage activity)</li> <li>Then reset <code>fuel_sold = 0</code>.</li> </ul>"},{"location":"core/economy.html#operating-cost-and-flights","title":"Operating Cost and Flights","text":"<ul> <li>Operating cost charged per flight hour using <code>operating_cost</code> from the airplane specs.</li> <li>Fuel consumption reduces onboard fuel and drives future refueling spend.</li> <li>Departures may also include scheduling/administrative overhead expressed via events.</li> </ul>"},{"location":"core/economy.html#strategy-notes","title":"Strategy Notes","text":"<ul> <li>Choose refueling hubs with cheaper fuel; plan routes to balance runway limits and deadlines.</li> <li>Larger airports generate more orders and may pay more but also have higher fees.</li> <li>Fleet composition matters: payload capacity, cruise speed, and runway requirement impact profitability.</li> </ul>"},{"location":"core/errors.html","title":"Errors","text":"<p>Operations can fail with <code>GameError</code>. Messages are designed to be user\u2011friendly and often include contextual values.</p>"},{"location":"core/errors.html#error-types","title":"Error Types","text":"<ul> <li>OutOfRange { distance, range } \u2014 requested flight exceeds aircraft range.</li> <li>RunwayTooShort { required, available } \u2014 destination runway shorter than aircraft requirement.</li> <li>MaxPayloadReached { current_capacity, maximum_capacity, added_weight } \u2014 loading would exceed payload capacity.</li> <li>OrderIdInvalid { id } \u2014 no such order at current airport.</li> <li>PlaneIdInvalid { id } \u2014 no such plane.</li> <li>AirportIdInvalid { id } \u2014 no such airport.</li> <li>AirportLocationInvalid { location } \u2014 no airport at coordinate.</li> <li>PlaneNotAtAirport { plane_id } \u2014 action requires being parked (not in transit).</li> <li>PlaneNotReady { plane_state } \u2014 current status disallows the action.</li> <li>InsufficientFunds { have, need } \u2014 not enough cash to complete purchase/operation.</li> <li>InsufficientFuel { have, need } \u2014 not enough fuel for the requested flight.</li> <li>UnknownModel { input, suggestion } \u2014 airplane model not recognized; includes suggestion via edit\u2011distance when close.</li> <li>NoCargo \u2014 attempted unload but manifest is empty.</li> <li>SameAirport \u2014 attempted to depart to current airport.</li> <li>InvalidCommand { msg } \u2014 CLI/Python command parsing failed.</li> </ul>"},{"location":"core/errors.html#recovery-tips","title":"Recovery Tips","text":"<ul> <li>OutOfRange \u2014 refuel en\u2011route (if possible), fly shorter legs, choose reachable destination, or buy a longer\u2011range model.</li> <li>RunwayTooShort \u2014 choose airports with longer runways or different airplane models.</li> <li>MaxPayloadReached \u2014 unload or choose a heavier\u2011lift model.</li> <li>InsufficientFunds \u2014 reduce expenses, deliver more orders, or buy a cheaper plane.</li> <li>InsufficientFuel \u2014 refuel before departure or at intermediate stops.</li> </ul>"},{"location":"core/events.html","title":"Events and Time","text":"<p>RustyRunways advances in integer hours (<code>GameTime = u64</code>). The engine uses a priority queue of scheduled events; the earliest event executes next. Calling <code>advance(n)</code> progresses to the target time or until no events remain.</p>"},{"location":"core/events.html#event-types","title":"Event Types","text":"<ul> <li>LoadingEvent { plane }</li> <li>Completes loading an order onto a plane (+1h from when scheduled).</li> <li>FlightTakeOff { plane, origin, destination }</li> <li>Marks the start of a flight and transitions plane to <code>InTransit</code>.</li> <li>FlightProgress { plane }</li> <li>Intermediate progress ticks for long flights (if used by the engine).</li> <li>RefuelComplete { plane }</li> <li>Completes refueling and charges fuel costs.</li> <li>OrderDeadline { airport, order }</li> <li>Deadline reached for an order; failure penalties may apply.</li> <li>Restock</li> <li>Periodic restocking of orders at airports.</li> <li>DailyStats</li> <li>Aggregates income/expenses delta for daily reporting.</li> <li>DynamicPricing</li> <li>Every <code>fuel_interval_hours</code>, raises or lowers airport fuel prices by the configured elasticity, clamped between the configured minimum and maximum multipliers of each airport's base price.</li> <li>WorldEvent { airport, factor, duration }</li> <li>Temporary world/airport factor altering prices/fees for <code>duration</code> hours.</li> <li>WorldEventEnd { airport, factor }</li> <li>Ends a <code>WorldEvent</code> and restores base conditions.</li> <li>MaintenanceCheck</li> <li>Routine checks that can prevent breakdowns; scheduled regularly.</li> <li>Maintenance { plane }</li> <li>Finishes a maintenance action (+1h from scheduling).</li> </ul>"},{"location":"core/events.html#scheduling-mechanics","title":"Scheduling Mechanics","text":"<ul> <li>Actions like load/unload/refuel/maintenance schedule their completion at <code>now + 1h</code>.</li> <li>Departures schedule plane transit and arrival at <code>now + flight_time</code>.</li> <li>Pricing and restocking are scheduled periodically.</li> </ul>"},{"location":"core/events.html#advancing-time","title":"Advancing Time","text":"<ul> <li><code>advance(hours)</code> repeatedly pops due events and executes them until the target time or queue is empty.</li> <li>The game\u2019s <code>time</code> is set to the time of the last processed event (or the target if idle).</li> </ul>"},{"location":"dev/coverage.html","title":"Code Coverage","text":"<p>We measure coverage for both the Rust engine and the Python bindings. Our goal is at least 80% line coverage for each.</p>"},{"location":"dev/coverage.html#local-run","title":"Local run","text":"<p>Use the helper script from the repo root:</p> <pre><code>scripts/coverage.sh\n</code></pre> <p>It runs:</p> <ul> <li>Rust: <code>cargo tarpaulin</code> with a Cobertura XML report in <code>coverage/rust/cobertura.xml</code>.</li> <li>Python: <code>pytest --cov</code> with an XML report in <code>coverage/python/coverage.xml</code>.</li> </ul> <p>Thresholds (both default to 80%) can be overridden via env vars:</p> <pre><code>RUST_FAIL_UNDER=85 PY_FAIL_UNDER=85 scripts/coverage.sh\n</code></pre>"},{"location":"dev/coverage.html#ci","title":"CI","text":"<p>The <code>Coverage</code> GitHub Action executes on every PR and on pushes to <code>main</code>:</p> <ul> <li>File: <code>.github/workflows/coverage.yml</code></li> <li>Fails the job if either Rust or Python coverage drops below 80%.</li> <li>Uploads artifacts under the <code>coverage/</code> directory for inspection.</li> </ul>"},{"location":"dev/coverage.html#whats-included","title":"What\u2019s included","text":"<ul> <li>Rust: All crates except the Python extension crate (<code>rusty_runways_py</code>) are measured. Integration tests are executed via Tarpaulin.</li> <li>Python: Tests under <code>crates/py/tests</code> run against the local dev build (via <code>maturin develop</code>).</li> </ul>"},{"location":"dev/coverage.html#future-work","title":"Future work","text":"<ul> <li>Frontend (React) coverage: we currently do not include the UI in coverage. We can add Vitest + jsdom and collect coverage from TS/TSX files in <code>apps/tauri/ui/src</code> if desired.</li> </ul>"},{"location":"gui/index.html","title":"GUI","text":"<p>RustyRunways ships with two GUIs:</p> <ul> <li>Tauri + React desktop app (recommended): a polished UI that bundles the web frontend with a native shell via Tauri. It looks nicer, supports full-screen map, and is available as installers for macOS, Windows, and Linux. See Downloads: Releases.</li> <li>Web Demo: run the same UI in your browser via WebAssembly. Great for a quick try \u2014 no install. Play Online</li> <li>egui desktop app: a lightweight Rust/egui client primarily used during early development. It remains available under <code>crates/gui</code> but is not distributed as prebuilt binaries.</li> </ul> <p>Both UIs use the same Core engine and commands. See Core for the game mechanics.</p>"},{"location":"gui/index.html#layout","title":"Layout","text":"<ul> <li>Top header: game title, cash, current time, fleet size, and buttons for Save/Load/Menu/Exit.</li> <li>Right sidebar: stats (income/expenses/deliveries), fleet list (click to open plane), airports list (click to open airport), quick actions.</li> <li>Center: world map with airports and planes; hover for details, click to select, overlapping targets show a context popup.</li> <li>Bottom panel: full\u2011width game log with sticky scrolling.</li> </ul>"},{"location":"gui/index.html#start-from-config","title":"Start From Config","text":"<ul> <li>Main menu includes a \u201cStart From Config\u201d section with:</li> <li>Path input and a Browse file picker (YAML/YML) via native dialog.</li> <li>Preview window listing all parsed airports and fees.</li> <li>Start launches a new game using the YAML config.</li> </ul>"},{"location":"gui/index.html#panels-windows","title":"Panels &amp; Windows","text":"<ul> <li>Airport window</li> <li>Overview: ID, location, runway, fees, fuel price.</li> <li>Outstanding orders list.</li> <li> <p>Load Order(s): select single or multiple orders and a plane at this airport; load via buttons.</p> </li> <li> <p>Plane window</p> </li> <li>Overview: model, fuel, payload.</li> <li>Manifest list.</li> <li>Reachable airports (feasibility relative to this plane).</li> <li>Actions: Refuel, Unload All, Maintenance, Sell (parked &amp; empty only).</li> <li>Load Order(s):<ul> <li>Filters: destination and min/max weight.</li> <li>Single\u2011select and multi\u2011select order lists with detailed labels.</li> </ul> </li> <li>Dispatch: destination dropdown and Depart button.</li> </ul>"},{"location":"gui/index.html#buying-planes","title":"Buying Planes","text":"<ul> <li>Click \u201cBuy new plane\u201d next to Fleet Overview.</li> <li>In the dialog:</li> <li>Select a model; specs are displayed (price, payload, cruise, fuel, burn, operating cost, runway requirement).</li> <li>Select the starting airport; runway suitability is annotated.</li> <li>Balance indicator shows price, cash, and affordability; purchase is disabled unless cash and runway constraints are satisfied.</li> </ul>"},{"location":"gui/index.html#responsiveness-ux","title":"Responsiveness &amp; UX","text":"<ul> <li>Resizable panels and windows; stable sizes for Save/Load and info windows.</li> <li>Multi\u2011order selection and filters improve throughput when dispatching multiple orders.</li> <li>Log panel spans full width and sticks to the latest message.</li> </ul>"},{"location":"gui/index.html#getting-the-desktop-app","title":"Getting the desktop app","text":"<ul> <li>Download installers from the Releases page. We publish cross\u2011platform builds for every tagged release. On macOS we ship a universal binary that runs on both Apple Silicon and Intel.</li> <li>Developers can run the app from source:</li> <li>Dev mode: <code>scripts/dev_tauri.sh</code> (starts Vite + Tauri window)</li> <li>Build: <code>cd apps/tauri/src-tauri &amp;&amp; cargo tauri build</code></li> </ul> <p>Limitations in the web demo: - Save/load and YAML scenarios are not available in the browser. Use the Python wrappers, Tauri desktop app, or native Rust builds for those workflows.</p>"},{"location":"python/index.html","title":"Python","text":"<p>The Python bindings expose the Rust core engine for scripting, data analysis, and reinforcement\u2011learning workflows. They respect the same economic defaults as the game clients: when you build an environment without a YAML override you start with $650\u202f000, a 12\u2011airport network, weekly restocks, and six\u2011hour fuel updates. Every CLI command can be issued from Python, so automated agents interact with the simulation just like human players.</p> <p>As part of the balancing process we routinely let heuristic agents play through procedurally generated worlds so we can observe cash curves, order feasibility, and upgrade cadence. The tooling used for that process lives in the <code>benchmarks/</code> directory and is referenced near the end of this document.</p>"},{"location":"python/index.html#installation","title":"Installation","text":"<ul> <li>PyPI (recommended):</li> </ul> <pre><code>pip install rusty-runways\n</code></pre> <ul> <li>With Gymnasium support (for Gym wrappers):</li> </ul> <pre><code>pip install 'rusty-runways[gym]'\n</code></pre> <ul> <li>Local dev build:</li> </ul> <pre><code>cd crates/py\nmaturin develop --release\n</code></pre>"},{"location":"python/index.html#imports-at-a-glance","title":"Imports at a Glance","text":"<ul> <li>Engine bindings: <code>from rusty_runways_py import GameEnv, VectorGameEnv</code></li> <li>Gym wrappers: <code>from rusty_runways import RustyRunwaysGymEnv, RustyRunwaysGymVectorEnv, make_sb3_envs</code></li> </ul> <p>Gymnasium is only required for the Gym wrappers. See the Gym section for details.</p>"},{"location":"python/index.html#gameenv-single-environment","title":"GameEnv (single environment)","text":"<p>Constructor</p> <pre><code>GameEnv(seed: int | None = None,\n        num_airports: int | None = None,\n        cash: float | None = None,\n        config_path: str | None = None)\n</code></pre> <p>Common usage</p> <pre><code>from rusty_runways_py import GameEnv\n\n# Start from a seeded random world\ng = GameEnv(seed=1, num_airports=5, cash=650_000)\ng.step(1)\nprint(g.time(), g.cash())\nprint(g.drain_log())\n\n# Start from a custom world YAML\ng2 = GameEnv(config_path=\"examples/sample_world.yaml\")\nprint(g2.time(), g2.cash())\n</code></pre> <p>Key methods</p> <ul> <li><code>reset(seed=None, num_airports=None, cash=None, config_path=None)</code>: Reinitialize the world.</li> <li><code>step(hours: int)</code>: Advance simulation time by <code>hours</code>.</li> <li><code>execute(cmd: str)</code>: Run CLI command (see CLI docs for syntax).</li> <li><code>sell_plane(plane_id: int) -&gt; float</code>: Sell a parked, empty plane (returns refund).</li> <li><code>state_json() -&gt; str</code>: JSON snapshot of the observable state.</li> <li><code>state_py() -&gt; dict</code>: Python dict snapshot (JSON decoded).</li> <li><code>full_state_json() -&gt; str</code>: Full internal state snapshot.</li> <li><code>load_full_state_json(s: str)</code>: Restore full internal state snapshot.</li> <li><code>time() -&gt; int</code>, <code>cash() -&gt; float</code>, <code>seed() -&gt; int</code>.</li> <li><code>drain_log() -&gt; list[str]</code>: Retrieve and clear sim log.</li> <li><code>orders_at_plane(plane_id: int) -&gt; list[int]</code>: Order IDs available at that plane\u2019s airport.</li> <li><code>airport_ids() -&gt; list[int]</code>: All airport IDs in the world.</li> <li><code>models_json() -&gt; str</code>: JSON list of available airplane models (name + specs) for the current game.</li> <li><code>models_py(py) -&gt; list[dict]</code>: Python list version of the above.</li> </ul> <p>Inspecting state</p> <pre><code>obs = g.state_py()\nprint(obs[\"airports\"][0])\nprint(obs[\"planes\"][0])\n</code></pre>"},{"location":"python/index.html#vectorgameenv-multiple-environments","title":"VectorGameEnv (multiple environments)","text":"<p>Constructor</p> <pre><code>VectorGameEnv(n_envs: int,\n              seed: int | None = None,\n              num_airports: int | None = None,\n              cash: float | None = None,\n              config_path: str | None = None)\n</code></pre> <p>Core vector API</p> <ul> <li><code>env_count() / __len__()</code>: Number of envs.</li> <li><code>seeds() -&gt; list[int]</code>: Per\u2011env seeds.</li> <li><code>reset_all(seed=None, num_airports=None, cash=None)</code>: Vector reset; values can be scalars or lists.</li> <li><code>reset_at(idx, seed=None, num_airports=None, cash=None)</code>: Reset a single env.</li> <li><code>step_all(hours, parallel=True)</code>: Advance all envs (Rayon\u2011parallel when <code>parallel=True</code>).</li> <li><code>step_masked(hours, mask, parallel=True)</code>: Advance a subset by boolean mask.</li> <li><code>execute_all(cmds, parallel=True) -&gt; list[tuple[bool, Optional[str]]]</code>: Run a command (or <code>None</code>) per env.</li> <li><code>state_all_json() / state_all_py()</code>: Vector snapshots.</li> <li><code>times() -&gt; list[int]</code>, <code>cashes() -&gt; list[float]</code>, <code>drain_logs() -&gt; list[list[str]]</code>.</li> <li><code>orders_at_plane_all(plane_id) -&gt; list[list[int]]</code>, <code>airport_ids_all() -&gt; list[list[int]]</code>.</li> <li><code>sell_plane(env_idx: int, plane_id: int) -&gt; float</code>: Sell a plane in a specific environment.</li> </ul> <p>Examples</p> <pre><code>from rusty_runways_py import VectorGameEnv\n\nenv = VectorGameEnv(4, seed=1)\nenv.step_all(1, parallel=True)\nprint(env.times())        # [1, 1, 1, 1]\nprint(env.cashes())\n\n# Determinism check: parallel vs serial stepping\nserial = VectorGameEnv(4, seed=1)\nenv.step_all(3, parallel=True)\nserial.step_all(3, parallel=False)\nassert env.times() == serial.times() == [4, 4, 4, 4]\n\n# Start from a custom world for all envs\nenv2 = VectorGameEnv(4, config_path=\"examples/sample_world.yaml\")\nprint(env2.times())\n</code></pre>"},{"location":"python/index.html#gymnasium-wrappers","title":"Gymnasium Wrappers","text":"<p>Wrappers live under the pure\u2011Python package <code>rusty_runways</code> and require <code>gymnasium</code>:</p> <ul> <li><code>RustyRunwaysGymEnv</code>: Single\u2011env wrapper over <code>GameEnv</code>.</li> <li><code>RustyRunwaysGymVectorEnv</code>: Vector wrapper over <code>VectorGameEnv</code> (implements <code>gym.vector.VectorEnv</code>).</li> <li><code>make_sb3_envs(n_envs, seed=None, **kwargs)</code>: Convenience to build <code>DummyVecEnv</code>/<code>SubprocVecEnv</code> inputs for SB3.</li> </ul> <p>Observation and action spaces</p> <ul> <li>Observation: <code>Box(float32, shape=(14,))</code> summary features derived from state JSON.</li> <li>Action: <code>MultiDiscrete([6, 16, 64, 256])</code> encoding <code>[op, plane_id, selector, dest_index]</code> where <code>op</code> in   0 ADVANCE, 1 REFUEL, 2 UNLOAD_ALL, 3 MAINTENANCE, 4 DEPART_TO_INDEX, 5 LOAD_ORDER.</li> <li>Reward: By default, delta cash per step; can be customized with <code>reward_fn(state, prev_state)</code> on the single\u2011env wrapper.</li> </ul> <p>Single\u2011env example</p> <pre><code>from rusty_runways import RustyRunwaysGymEnv\n\nenv = RustyRunwaysGymEnv(seed=1, num_airports=5)\nobs, info = env.reset()\nfor _ in range(10):\n    action = env.action_space.sample()\n    obs, reward, terminated, truncated, info = env.step(action)\n    if terminated or truncated:\n        obs, info = env.reset()\n</code></pre> <p>Vector (Gym VectorEnv) example</p> <pre><code>from rusty_runways import RustyRunwaysGymVectorEnv\n\nvenv = RustyRunwaysGymVectorEnv(8, seed=123, num_airports=5)\nobs, info = venv.reset()\nacts = venv.action_space.sample()\nvenv.step_async(acts)\nobs, rewards, terminated, truncated, infos = venv.step_wait()\n</code></pre> <p>Stable\u2011Baselines3 example</p> <pre><code>from stable_baselines3 import PPO\nfrom stable_baselines3.common.vec_env import DummyVecEnv\nfrom rusty_runways import make_sb3_envs\n\nvec_env = DummyVecEnv(make_sb3_envs(4, seed=1, num_airports=5))\nmodel = PPO(\"MlpPolicy\", vec_env, verbose=1)\nmodel.learn(total_timesteps=10_000)\n</code></pre> <p>Dependency note</p> <ul> <li>Install via extra for full features: <code>pip install 'rusty-runways[gym]'</code>.</li> <li>Or install directly: <code>pip install gymnasium</code>.</li> <li>If Gymnasium is not installed, attempting to use the wrappers will raise a helpful ImportError explaining how to enable them.</li> </ul>"},{"location":"python/index.html#notes","title":"Notes","text":"<ul> <li>The bindings enforce the same constraints as the Rust engine: planes must be parked to refuel or sell, deadlines continue to expire, and economic defaults mirror the tuned values.</li> <li>Seeds control determinism. When you pass a scalar seed to <code>VectorGameEnv</code>, each environment receives <code>seed + index</code>, so parallel runs remain reproducible.</li> <li>Parallel stepping releases the GIL and uses Rayon internally, allowing large vector environments to scale efficiently across CPU cores.</li> </ul>"},{"location":"python/index.html#loading-yaml-worlds","title":"Loading YAML Worlds","text":"<p>All constructors accept <code>config_path</code>. The engine reads the YAML, applies defaults for any missing fields, and returns an environment seeded with those parameters. This pattern makes balance testing fast, because you can edit the YAML on disk, call <code>reset(config_path=...)</code>, and immediately observe how the new weights, deadlines, or restock cadence influence the simulation.</p> <pre><code>from rusty_runways_py import GameEnv\n\nenv = GameEnv(config_path=\"benchmarks/sanity.yaml\")\nprint(env.cash(), env.seed())\nenv.execute(\"SHOW AIRPORTS WITH ORDERS\")\n</code></pre> <p>To build YAML files programmatically (for sweeps or automated tests), write them to a temporary path with <code>yaml.safe_dump</code>, hand that path to <code>GameEnv</code> or <code>VectorGameEnv</code>, and delete the file once the run completes. The loader does not keep the file handle open after parsing.</p>"},{"location":"python/index.html#custom-airplane-catalog-in-yaml","title":"Custom Airplane Catalog in YAML","text":"<p>World YAML supports a top\u2011level <code>airplanes</code> section that either replaces or extends the built\u2011in catalog:</p> <pre><code>airplanes:\n  strategy: add      # or: replace\n  models:\n    - name: WorkshopCombi\n      mtow: 15000.0\n      cruise_speed: 520.0\n      fuel_capacity: 3200.0\n      fuel_consumption: 260.0\n      operating_cost: 950.0\n      payload_capacity: 3200.0\n      passenger_capacity: 24\n      purchase_price: 780000.0\n      min_runway_length: 1200.0\n      role: Mixed        # Cargo | Passenger | Mixed\n</code></pre> <p>After loading a YAML with custom airplanes, query the models from Python:</p> <pre><code>from rusty_runways_py import GameEnv\n\ng = GameEnv(config_path=\"examples/sample_world.yaml\")\nmodels = g.models_py()\nprint([m[\"name\"] for m in models])\n</code></pre>"},{"location":"python/index.html#sanity-benchmarks-and-the-heuristic-agent","title":"Sanity Benchmarks and the Heuristic Agent","text":"<p>The <code>benchmarks/</code> folder contains a deterministic heuristic agent used during development. Running it regularly helps verify that code or tuning changes keep the starter plane\u2019s feasibility and upgrade timing inside the target window.</p> <ol> <li>Edit or create a scenario file (for example <code>benchmarks/sanity.yaml</code>).</li> <li>Execute <code>python benchmarks/run_benchmarks.py --scenario-config benchmarks/sanity.yaml</code> to simulate all listed seeds.</li> <li>Render per-seed charts with <code>python benchmarks/sanity_report.py</code>. The script writes feasibility, margin, cash, and route-length plots for early/mid/late phases alongside a JSON summary so you can diff statistics between branches.</li> </ol> <p>These scripts rely solely on the public Python API, so you can copy their helpers into custom analytics pipelines or reinforcement-learning loops.</p>"},{"location":"python/index.html#benchmark-agents","title":"Benchmark Agents","text":"<p>The repository contains a small benchmarking harness (see <code>benchmarks/run_benchmarks.py</code>) that exercises the Python bindings using a greedy hauling agent. This script evaluates multiple seeds in one go, records cash/fleet/delivery timelines, and renders plots summarizing the progression. To experiment with it locally:</p> <ol> <li>Initialise the virtual environment and build the bindings from source:</li> </ol> <pre><code>./benchmarks/setup.sh\nsource benchmarks/.venv/bin/activate\n</code></pre> <ol> <li>Run the benchmarking driver:</li> </ol> <pre><code>python benchmarks/run_benchmarks.py --seeds 0 1 2 --hours 168 --airports 12\n</code></pre> <p>The script prints per-seed statistics (order feasibility, margin-per-hour, upgrade timing). It also emits CSV timelines and PNG plots under <code>benchmarks/outputs/</code> so you can inspect cash/fleet/delivery curves by seed.</p> <p>For exploratory analysis you can now describe arbitrarily rich batches in YAML and pass them via <code>--scenario-config</code>. Each scenario may define:</p> <ul> <li>the world knobs (<code>num_airports</code>, <code>starting_cash</code>, <code>gameplay.orders.*</code>, etc.); the runner creates temporary YAML configs and cleans them up afterwards;</li> <li>sweeps over a single parameter (e.g., vary only <code>gameplay.restock_cycle_hours</code>) or named variants with bespoke overrides;</li> <li>the seed list and duration for each variant.</li> </ul> <p>All runs end up under <code>benchmarks/outputs/&lt;scenario&gt;/</code> alongside a CSV timeline per seed. The driver also produces a <code>scenario_summary.csv</code> plus aggregate line/bar charts in <code>benchmarks/outputs/summary/</code>, letting you isolate the impact of the swept parameter (restock cadence, order weights, fuel intervals, and so on).</p> <p>An abridged configuration example:</p> <pre><code>defaults:\n  hours: 240\n  seeds: [0, 1, 2]\n  cash: 650000.0\n  num_airports: 12\n  gameplay:\n    restock_cycle_hours: 168\n    fuel_interval_hours: 6\n    orders:\n      regenerate: true\n      generate_initial: true\n      max_deadline_hours: 96\n      min_weight: 180.0\n      max_weight: 650.0\n      alpha: 0.12\n      beta: 0.55\n\nscenarios:\n  - name: baseline\n  - name: restock-sweep\n    sweep:\n      parameter: gameplay.restock_cycle_hours\n      values: [96, 120, 168, 240]\n  - name: order-weight-variants\n    variants:\n      - label: light-cargo\n        overrides:\n          gameplay:\n            orders:\n              min_weight: 150.0\n              max_weight: 600.0\n</code></pre> <p>See <code>benchmarks/scenarios.example.yaml</code> for a more complete walkthrough including external <code>config_path</code> worlds.</p> <p>Feel free to adapt the harness for richer experiments (e.g., alternative agents, different reward functions, or automated regression checks). Because it builds against the local branch, the outputs always reflect the current balance knobs.</p>"}]}